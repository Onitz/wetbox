<!DOCTYPE html>
<html>
<head>
<style>
html,body{
  margin:0;
  padding:0;
  font-family:Arial,sans-serif;
  font-size:12px;
}
table{
  border-collapse:collapse;
}
td,th{
  width:15px;
  height:15px;
  border:1px solid #aaa;
  background-color:#fff;
}
tr:last-child, td:first-child{
  color:#aaa;
}
td:last-child {
  background-color:#aaa;
  border:none;
  border-radius:0 15px 0 0;
}
#bestpc{
  font-size:30px;
  font-weight:bold;
  padding:10px;
}
#besttiks{
  width:100%;
  min-height:200px;
}
</style>
</head>
<body><div id="bestpc"></div><textarea id="besttiks"></textarea></body>
<script>
// N CHOOSE K ----------------------------------------------------------------------------------------- 
N = 45;
K = 6;
// -------- buy X tickets
X = 200

tiks = [
  [01,02,03,04,05,06]
];

// Spawn the table
(function proceduallyGenerateTriangle(n) {
  let table = document.createElement("table")
  table.setAttribute('cellpadding',0);
  table.setAttribute('cellspacing',0);
  document.body.prepend(table);

  // Row generation
  for(let i=0;i<(n+2);i++) {
    let row = document.createElement("tr");
    row.setAttribute('id','r'+i)
    table.appendChild(row);

    //r0 and rn+1 are horizontal label rows 
    if( i===0 || i===(n+1)) {
      for(let k=0;k<=(n+1);k++) {
        let cell = document.createElement("td");
        row.appendChild(cell);
        if(k!==0 && k!==(n+1) ) {
          let labl = document.createTextNode(k.toString().padStart(2,'0'));
          cell.appendChild(labl);
        } else if(i===0 && k===(n+1)) {
          cell.style.backgroundColor ='#fff';
        }
      }
      continue;
    }

    // Regular column generation
    for(let j=0;j<=i;j++) { 
      let cell = document.createElement("td");
      row.appendChild(cell);

      if(j===0) {
        let labl = document.createTextNode(i.toString().padStart(2,'0'));
        cell.appendChild(labl);
      }
    }
  }
})(N)


function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}

function quickpick() {
  for (var a=[],i=0;i<N;++i) a[i]=i+1;
  a = shuffle(a);
  return a.slice(0,K);
}
console.log(quickpick());

function quickpickn(n) {
  tiks = [];
  for(let i=0;i<n;i++) {
    tiks[i] = quickpick();
  }
}

blankSlate = [
  [0],
  [0,0],
  [0,0,0],
  [0,0,0,0],
  [0,0,0,0,0],
  [0,0,0,0,0,0],
  [0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
]; //border of dataset should be all zeros (visually obvious if this cond is broken)

state = null;
stateCoverage = 0; //number between 0 and 595

function resetState() {
  state = JSON.parse(JSON.stringify(blankSlate));
  stateCoverage = 0; //max is 
}
resetState();

let clashOfColors = [
  'black',
  '#0f0',
  'yellow',
  'orange',
  'red',
];

function computeState() {
  //state = JSON.parse(JSON.stringify(blankSlate)); //force refresh the state

  for(let i=0;i<tiks.length;i++) {
    let tik = tiks[i];
    tik.sort((a,b)=>a-b); //By Default it sorts alphabetically, so will return [11,12,8,9], dumb. add lambda to fix
    // console.log(tik);

    if(tik.length === K) { //tik.length > 1 && tik.length < 8) {
      let a = tik[0];
      let b = tik[1];
      let c = tik[2];
      let d = tik[3];
      let e = tik[4];
      let f = tik[5];
      let g = tik[6];

      if(!a || !b || !c || !d || !e || !f) {
        console.error('UH OH, ZERO TICKET ENTRY')
      }

      state[b][a]++;
      state[c][a]++;
      state[d][a]++;
      state[e][a]++;
      state[c][b]++;
      state[d][b]++;

      state[d][c]++;

      state[e][b]++;
      state[e][c]++;
      state[e][d]++;

      state[f][a]++;
      state[f][b]++;
      state[f][c]++;
      state[f][d]++;
      state[f][e]++;

      if(g) {
        state[g][a]++;
        state[g][b]++;
        state[g][c]++;
        state[g][d]++;
        state[g][e]++;
        state[g][f]++;
      }
    }
  }

}

function drawState() { //drawstate or countstate
  for(let i=0;i<(N+2);i++) { //row iterator
    for(let j=0;j<=i;j++) { //col iterator (init to zero to test lower bound)
      let val = state[i][j];
      let cel = document.getElementById(`r${i}`).children[j];
      cel.style.backgroundColor = clashOfColors[Math.min( val, clashOfColors.length - 1)];
    }
  }
}

function countState() {
  let ret = 0;
  for(let i=1;i<(N+2);i++) { //row iterator
    for(let j=1;j<=i;j++) { //col iterator (init to zero to test lower bound)
      if(state[i][j]>0) ret++;
    }
  }
  stateCoverage = ret;
  return ret;
}

function update() { 
  resetState();
  computeState();
  countState();
}

update();

bestTiks = [];
bestStateCoverage = 0;

function printBest() {
  console.log(JSON.stringify(bestTiks));
}

for(let i=0;i<999;i++){
  quickpickn(X);
  update();
  if(stateCoverage > bestStateCoverage) { // we have a new beststate 
    bestStateCoverage = stateCoverage;
    bestTiks = tiks;
  }
}
tiks=bestTiks;
bestpc = ((stateCoverage/choose(N,K))*100).toFixed(2);
computeState();
countState();
drawState();

document.getElementById('bestpc').innerText = bestpc+'%';
document.getElementById('besttiks').value = JSON.stringify(bestTiks);


//this time its 45 Choose 6 = 45/6*44/5*43/4*42/3*41/2*40/1 = 8 145 060
function choose(n, k) {
  let ret = 1;
  for(let i=1;i<=k;i++){
    ret*=(n-k+i)/i;
  }
  return ret;
}

</script>
</html>