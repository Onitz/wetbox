<!DOCTYPE html>
<html>
<head>
<style>
html,body{
  margin:0;
  padding:0;
  font-family:Arial,sans-serif;
  font-size:12px;
}
table{
  border-collapse:collapse;
}
td,th{
  width:15px;
  height:15px;
  border:1px solid #aaa;
  background-color:#fff;
}
tr:last-child, td:first-child{
  color:#aaa;
}
td:last-child {
  background-color:#aaa;
  border:none;
  border-radius:0 15px 0 0;
}
#bestpc{
  font-size:30px;
  font-weight:bold;
  padding:10px;
}
#besttiks{
  width:100%;
  min-height:300px;
}
button {
  float:right;
  width:200px;
  height:50px;
}
</style>
</head>
<body>
  <div id="bestpc"></div>
  <div>Number of tickets: <span id="ntix"></span></div>
  <button onClick="randomTry()">Try</button>
  <button onClick="backTik()">Remove</button>
  <button onClick="randomAdd()">Add</button>
  <button onClick="resetTiks()">Reset</button>
  <button onClick="loadTiks()">Load</button>
  <textarea id="besttiks"></textarea>
</body>
<script>
// N CHOOSE K ----------------------------------------------------------------------------------------- 
N = 35;
K = 7;

// -------- buy X tickets ----------------------------------------------------------------------------------------- 
state = null;
X = 15; //30 = $720
ITER = 500;

TRY_ITER=100000; //hillclimb iters
// 35c2 = 595
// 595/7c2 =  595 / 21 = 28.33 = 29 powerhits lower bound for full coverage (29*24 = AU$696)

//non-empty will prevent loading the pre-generation
tiks = [];

function randomAdd() {
  tiks.push(quickpick());
  update();
  drawState();

  let bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
  document.getElementById('ntix').innerText = tiks.length;
  document.getElementById('bestpc').innerText = bestpc+'%';
  document.getElementById('besttiks').value = JSON.stringify(tiks);
}

function loadTiks() {
  tiks=JSON.parse(document.getElementById('besttiks').value);
  update();
  drawState();

  let bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
  document.getElementById('ntix').innerText = tiks.length;
  document.getElementById('bestpc').innerText = bestpc+'%';
  document.getElementById('besttiks').value = JSON.stringify(tiks);
}

function resetTiks() {
  tiks = [];
  update();
  drawState();

  let bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
  document.getElementById('ntix').innerText = tiks.length;
  document.getElementById('bestpc').innerText = bestpc+'%';
  document.getElementById('besttiks').value = JSON.stringify(tiks);
}

function backTik() {
  tiks.pop();
  update();
  drawState();

  let bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
  document.getElementById('ntix').innerText = tiks.length;
  document.getElementById('bestpc').innerText = bestpc+'%';
  document.getElementById('besttiks').value = JSON.stringify(tiks);
}

function randomTry() {
  let bestCandidate=[];
  let bestScore=0;
  let bestPossibleScore=choose(K,2);

  for(let i=0;i<TRY_ITER;i++){
    let candidate = quickpick();
    candidate.sort((a,b)=>b-a); //reverse order lets us index by [1][2] (ie forward-ordered indexing on reverse-ordered ticket)
    let score = 0;
    score += state[candidate[0]][candidate[1]] < 1 ? 1 : 0;
    score += state[candidate[0]][candidate[2]] < 1 ? 1 : 0;
    score += state[candidate[0]][candidate[3]] < 1 ? 1 : 0;
    score += state[candidate[0]][candidate[4]] < 1 ? 1 : 0;
    score += state[candidate[0]][candidate[5]] < 1 ? 1 : 0;
    score += state[candidate[0]][candidate[6]] < 1 ? 1 : 0;

    score += state[candidate[1]][candidate[2]] < 1 ? 1 : 0;
    score += state[candidate[1]][candidate[3]] < 1 ? 1 : 0;
    score += state[candidate[1]][candidate[4]] < 1 ? 1 : 0;
    score += state[candidate[1]][candidate[5]] < 1 ? 1 : 0;
    score += state[candidate[1]][candidate[6]] < 1 ? 1 : 0;

    score += state[candidate[2]][candidate[3]] < 1 ? 1 : 0;
    score += state[candidate[2]][candidate[4]] < 1 ? 1 : 0;
    score += state[candidate[2]][candidate[5]] < 1 ? 1 : 0;
    score += state[candidate[2]][candidate[6]] < 1 ? 1 : 0;

    score += state[candidate[3]][candidate[4]] < 1 ? 1 : 0;
    score += state[candidate[3]][candidate[5]] < 1 ? 1 : 0;
    score += state[candidate[3]][candidate[6]] < 1 ? 1 : 0;

    score += state[candidate[4]][candidate[5]] < 1 ? 1 : 0;
    score += state[candidate[4]][candidate[6]] < 1 ? 1 : 0;

    score += state[candidate[5]][candidate[6]] < 1 ? 1 : 0;

    if(score > bestScore) {
      bestCandidate = candidate;
      bestScore = score;

      if(score===bestPossibleScore) {
        break;
      }
    }
  }

  if(bestCandidate.length!==0) {
    tiks.push(bestCandidate);
  }
  update();
  drawState();

  let bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
  document.getElementById('ntix').innerText = tiks.length;
  document.getElementById('bestpc').innerText = bestpc+'%';
  document.getElementById('besttiks').value = JSON.stringify(tiks);
}

function randomTryN(n) {
  tiks = [];
  for(let i=0;i<n;i++) {
    randomTry();
  }
  let bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
  console.log('randomTryN found',bestpc,'%');
}

// Spawn the table
(function proceduallyGenerateTriangle(n) {
  let table = document.createElement("table")
  table.setAttribute('cellpadding',0);
  table.setAttribute('cellspacing',0);
  document.body.prepend(table);

  // Row generation
  for(let i=0;i<(n+2);i++) {
    let row = document.createElement("tr");
    row.setAttribute('id','r'+i)
    table.appendChild(row);

    //r0 and rn+1 are horizontal label rows 
    if( i===0 || i===(n+1)) {
      for(let k=0;k<=(n+1);k++) {
        let cell = document.createElement("td");
        row.appendChild(cell);
        if(k!==0 && k!==(n+1) ) {
          let labl = document.createTextNode(k.toString().padStart(2,'0'));
          cell.appendChild(labl);
        } else if(i===0 && k===(n+1)) {
          cell.style.backgroundColor ='#fff';
        }
      }
      continue;
    }

    // Regular column generation
    for(let j=0;j<=i;j++) { 
      let cell = document.createElement("td");
      row.appendChild(cell);

      if(j===0) {
        let labl = document.createTextNode(i.toString().padStart(2,'0'));
        cell.appendChild(labl);
      }
    }
  }
})(N)


function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}

function quickpick() {
  for (var a=[],i=0;i<N;++i) a[i]=i+1;
  a = shuffle(a);
  return a.slice(0,K);
}
console.log(quickpick());

function quickpickn(n) {
  tiks = [];
  for(let i=0;i<n;i++) {
    tiks[i] = quickpick();
  }
}

blankSlate = [
  [0],
  [0,0],
  [0,0,0],
  [0,0,0,0],
  [0,0,0,0,0],
  [0,0,0,0,0,0],
  [0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
]; //border of dataset should be all zeros (visually obvious if this cond is broken)

function resetState() {
  state = JSON.parse(JSON.stringify(blankSlate));
}
resetState();

let clashOfColors = [
  'black',
  '#0f0',
  'yellow',
  'orange',
  'red',
];

function computeState() {
  //state = JSON.parse(JSON.stringify(blankSlate)); //force refresh the state

  for(let i=0;i<tiks.length;i++) {
    let tik = tiks[i];
    tik.sort((a,b)=>a-b); //By Default it sorts alphabetically, so will return [11,12,8,9], dumb. add lambda to fix
    // console.log(tik);

    if(tik.length === K) { //tik.length > 1 && tik.length < 8) {
      let a = tik[0];
      let b = tik[1];
      let c = tik[2];
      let d = tik[3];
      let e = tik[4];
      let f = tik[5];
      let g = tik[6];

      if(!a || !b || !c || !d || !e || !f) {
        console.error('UH OH, ZERO TICKET ENTRY')
      }

      state[b][a]++;
      state[c][a]++;
      state[d][a]++;
      state[e][a]++;
      state[c][b]++;
      state[d][b]++;

      state[d][c]++;

      state[e][b]++;
      state[e][c]++;
      state[e][d]++;

      state[f][a]++;
      state[f][b]++;
      state[f][c]++;
      state[f][d]++;
      state[f][e]++;

      if(g) {
        state[g][a]++;
        state[g][b]++;
        state[g][c]++;
        state[g][d]++;
        state[g][e]++;
        state[g][f]++;
      }
    }
  }

}

function drawState() { //drawstate or countstate
  for(let i=0;i<(N+2);i++) { //row iterator
    for(let j=0;j<=i;j++) { //col iterator (init to zero to test lower bound)
      let val = state[i][j];
      let cel = document.getElementById(`r${i}`).children[j];
      cel.style.backgroundColor = clashOfColors[Math.min( val, clashOfColors.length - 1)];
    }
  }
}

function stateCoverage() {
  let ret = 0;
  let k=0;
  for(let i=1;i<(N+1);i++) { //row iterator
    for(let j=1;j<i;j++) { //col iterator (init to zero to test lower bound)
      if(state[i][j]>0) ret++;
      //else console.log('NO COVERAGE AT ',i,j,'(',state[i][j],')');
    }
  }
  //console.log('state coverage=',stateCoverage);
  //console.log('',ret,'/',choose(N,2),'=',(100*ret/choose(N,2)).toFixed(2),'%' );
  return ret;
}

function update() { 
  resetState();
  computeState();
}
update();

bestTiks = JSON.parse(JSON.stringify(tiks));
bestStateCoverage = stateCoverage();

for(let i=0;i<ITER;i++){
  // just randomly pick 30, no climbing // quickpickn(X);
  randomTryN(X);

  update();
  let sc = stateCoverage();
  if(sc > bestStateCoverage) { // we have a new beststate 
    console.log(stateCoverage(),'is better than',bestStateCoverage,'?')
    bestStateCoverage = sc;
    bestTiks = JSON.parse(JSON.stringify(tiks)); //deep copy
  }
}

console.log('-------best');
tiks=JSON.parse(JSON.stringify(bestTiks));
update();
bestpc = ((stateCoverage()/choose(N,2))*100).toFixed(2);
drawState();

document.getElementById('bestpc').innerText = bestpc+'%';
document.getElementById('ntix').innerText = bestTiks.length;
document.getElementById('besttiks').value = JSON.stringify(bestTiks);


//this time its 45 Choose 6 = 45/6*44/5*43/4*42/3*41/2*40/1 = 8 145 060
function choose(n, k) {
  let ret = 1;
  for(let i=1;i<=k;i++){
    ret*=(n-k+i)/i;
  }
  return ret;
}

/*
66 tickets is absolute minimum lower bound for sat aka 6C2/45C2 = 15/990 = 66
29 tiks is the absolute min lower bound for thursday powerhit aka 7C2/35C2 = 21/595 = ciel(28.33) = 29

30 powerhits --
  89.75
  [[4,14,16,18,21,24,26],[1,6,8,19,20,23,30],[5,14,15,27,29,32,35],[8,10,11,17,18,25,29],[3,6,9,24,27,28,31],[7,12,13,26,28,30,33],[13,16,19,22,29,31,34],[1,2,9,11,13,15,21],[2,4,5,6,17,22,33],[3,4,12,15,23,25,34],[2,3,7,10,16,20,32],[9,14,20,25,33,34,35],[10,12,17,19,21,27,35],[5,7,11,22,23,24,35],[5,21,25,28,30,32,34],[1,5,9,12,18,22,32],[1,10,14,17,23,26,31],[2,8,24,25,26,27,34],[4,8,11,19,31,32,33],[8,9,15,16,17,28,30],[1,2,4,28,29,30,35],[6,7,15,18,20,21,31],[3,10,11,14,22,28,30],[3,18,21,23,27,29,33],[3,5,8,13,20,26,35],[6,11,12,16,20,27,29],[6,10,13,17,24,32,34],[7,9,15,19,24,26,29],[1,4,7,13,16,25,27],[2,13,14,18,19,23,28]]

15 powerhits ($360, 52.94% coverage theoretical limit) ---
51.09%
  [[2,4,5,7,24,27,34],[7,16,18,22,25,29,30],[1,3,11,23,26,28,34],[9,10,12,14,20,23,24],[1,5,14,21,30,31,35],[5,6,13,15,17,28,33],[10,17,21,26,27,29,32],[2,8,9,15,19,30,32],[3,4,13,20,22,31,32],[6,11,12,16,19,21,31],[2,12,18,20,26,33,35],[8,13,16,23,25,27,35],[1,4,6,9,17,19,25],[3,6,8,14,17,18,24],[8,10,11,22,29,33,34]]

51.60%
  [[5,7,10,18,19,20,25],[3,14,16,18,24,28,32],[2,7,16,21,27,29,34],[3,8,9,15,26,27,31],[6,9,10,14,17,21,33],[11,15,22,25,28,33,34],[4,12,18,30,31,34,35],[1,6,20,23,28,29,31],[11,12,13,19,23,27,32],[2,5,17,22,23,26,30],[1,4,8,19,21,22,24],[6,7,13,15,24,30,35],[4,10,13,14,25,26,29],[2,8,12,14,20,33,35],[1,9,10,16,22,32,35]]

51.60%
  [[1,2,7,8,9,16,35],[5,16,18,19,25,30,32],[3,11,12,16,29,31,34],[6,9,10,20,21,22,32],[6,8,24,26,28,29,30],[3,7,10,18,23,26,33],[13,14,15,18,20,24,35],[4,9,11,15,19,28,33],[7,17,19,21,24,27,34],[1,14,23,27,28,31,32],[4,8,12,14,17,22,25],[1,13,21,25,29,30,33],[2,5,6,12,13,17,23],[1,4,5,22,26,34,35],[2,10,15,22,25,30,31]]

51.93%
  [[1,2,9,18,21,31,35],[1,5,8,20,24,26,28],[9,10,12,15,20,22,30],[1,10,11,14,27,29,33],[6,8,11,13,17,22,31],[7,12,26,27,31,32,34],[3,7,14,17,20,21,23],[4,10,17,19,25,34,35],[2,3,16,22,24,25,27],[3,5,13,30,32,33,35],[4,6,15,16,23,26,33],[5,7,8,16,18,19,29],[4,14,18,24,28,30,34],[6,12,21,24,25,28,29],[2,11,15,19,23,28,32]]

RECORD FOR 100% coverage (lower is better)
39tiks,99.83% (i rekon you can plug the single remainder manually)
  [[4,14,16,18,21,24,26],[1,6,8,19,20,23,30],[5,14,15,27,29,32,35],[8,10,11,17,18,25,29],[3,6,9,24,27,28,31],[7,12,13,26,28,30,33],[13,16,19,22,29,31,34],[1,2,9,11,13,15,21],[2,4,5,6,17,22,33],[3,4,12,15,23,25,34],[2,3,7,10,16,20,32],[9,14,20,25,33,34,35],[10,12,17,19,21,27,35],[5,7,11,22,23,24,35],[5,21,25,28,30,32,34],[1,5,9,12,18,22,32],[1,10,14,17,23,26,31],[2,8,24,25,26,27,34],[4,8,11,19,31,32,33],[8,9,15,16,17,28,30],[1,2,4,28,29,30,35],[6,7,15,18,20,21,31],[3,10,11,14,22,28,30],[3,18,21,23,27,29,33],[3,5,8,13,20,26,35],[6,11,12,16,20,27,29],[6,10,13,17,24,32,34],[7,9,15,19,24,26,29],[1,4,7,13,22,25,27],[2,13,14,18,19,23,28],[5,6,16,19,25,31,35],[7,8,12,14,24,30,31],[1,10,15,16,24,33,34],[4,8,9,10,20,21,22],[3,7,17,18,19,34,35],[6,11,14,16,23,26,32],[17,18,20,24,27,28,30],[2,12,15,18,22,26,31],[1,3,5,9,10,21,23]]

HIGHEST EVERGREEN (single paired) ------------------------
(11) 38.82%
  [[2,3,5,9,10,28,34],[7,8,9,16,19,22,32],[4,18,20,21,23,32,34],[1,5,12,18,24,26,29],[8,10,14,20,26,30,33],[4,5,15,25,30,31,35],[6,10,11,17,22,29,31],[6,9,12,13,14,15,23],[1,2,11,21,25,27,33],[3,13,16,17,20,24,25],[7,17,23,26,27,28,35]]


HIGHEST 50% coverage
  15tiks, 51.76% (7 nongreen)
  [[1,3,5,7,33,34,35],[1,2,11,13,14,22,28],[3,4,15,19,20,24,32],[8,18,20,25,26,30,33],[6,7,9,23,25,27,31],[5,13,17,18,19,29,31],[2,10,12,15,30,31,35],[4,9,10,14,21,29,33],[12,13,16,20,21,23,34],[9,16,17,24,26,28,35],[5,6,8,10,11,16,32],[4,17,22,27,30,32,34],[3,6,8,12,22,26,29],[7,11,15,18,21,22,24],[1,2,8,19,21,26,27]]

-------

[[1,2,3,4,5,6,7],[7,8,9,10,11,12,13],[13,14,15,16,17,18,19],[19,20,21,22,23,24,25],[25,26,27,28,29,30,31]]
*/

</script>
</html>