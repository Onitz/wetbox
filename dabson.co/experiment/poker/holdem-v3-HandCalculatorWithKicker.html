<html>
<style>
.card{
  font-size:4.5em;
  line-height:.88em;
  width:.63em;
  background-color:#fff;
  display:inline-block;
  text-align:right;
  overflow:hidden;
  border-radius:.06em;
  border:.02em solid #000;
  margin:.03em;
  box-sizing:border-box;
}
.card span{
  position:relative;
  left:-.042em;
  top:.004em;
}
body{
  font-family:Arial,sans-serif;
  font-size:2em;
  background-color:#bfb;
}
</style>
<body></body>
<script>

const BASE = 13;
const M = [1, 13, 169, 2197, 28561, 371293]; // BASE-13 MULTIPLIERS = [0,1,2,3,4,5].map( x => Math.pow(BASE, x) )

asBase13 = x => parseInt( x ).toString( BASE );

function base13SubRank( tri, nth ) { // n=0 is most significant bit
  return Math.floor(  )
}

const RANK = [
  'Unranked',
  'High Card',
  'Pair',
  'Two Pair',
  'Three of a Kind',
  'Straight',
  'Flush',
  'Full House',
  'Four of a Kind',
  'Straight Flush',
  'Royal Flush',
];
[ 
  RANK.UNRANKED,
  RANK.HIGH_CARD,
  RANK.PAIR, 
  RANK.TWO_PAIR, 
  RANK.THREE_KIND,
  RANK.STRAIGHT,
  RANK.FLUSH,
  RANK.FULL_HOUSE,
  RANK.FOUR_KIND,
  RANK.STRAIGHT_FLUSH,
  RANK.ROYAL_FLUSH 
] = RANK;
RANK.TRI = n => n * M[5];
RANK.toString = function(triDecimal) {
  asBase13nthDigit
}

const CLUB2    =  0;
const CLUB3    =  1;
const CLUB4    =  2;
const CLUB5    =  3;
const CLUB6    =  4;
const CLUB7    =  5;
const CLUB8    =  8;
const CLUB9    =  7;
const CLUBT    =  8;
const CLUBJ    =  9;
const CLUBQ    = 10;
const CLUBK    = 11;
const CLUBA    = 12;

const DIAMOND2 = 13;
const DIAMOND3 = 14;
const DIAMOND4 = 15;
const DIAMOND5 = 16;
const DIAMOND6 = 17;
const DIAMOND7 = 18;
const DIAMOND8 = 19;
const DIAMOND9 = 20;
const DIAMONDT = 21;
const DIAMONDJ = 22;
const DIAMONDQ = 23;
const DIAMONDK = 24;
const DIAMONDA = 25;

const HEART2   = 26;
const HEART3   = 27;
const HEART4   = 28;
const HEART5   = 29;
const HEART6   = 30;
const HEART7   = 31;
const HEART8   = 32;
const HEART9   = 33;
const HEARTT   = 34;
const HEARTJ   = 35;
const HEARTQ   = 36;
const HEARTK   = 37;
const HEARTA   = 38;

const SPADE2   = 39;
const SPADE3   = 40;
const SPADE4   = 41;
const SPADE5   = 42;
const SPADE6   = 43;
const SPADE7   = 44;
const SPADE8   = 45;
const SPADE9   = 46;
const SPADET   = 47;
const SPADEJ   = 48;
const SPADEQ   = 49;
const SPADEK   = 50;
const SPADEA   = 51;

const clubMap    = [127186,127187,127188,127189,127190,127191,127192,127193,127194,127195,127197,127198,127185];
const diamondMap = [127170,127171,127172,127173,127174,127175,127176,127177,127178,127179,127181,127182,127169];
const heartMap   = [127154,127155,127156,127157,127158,127159,127160,127161,127162,127163,127165,127166,127153];
const spadeMap   = [127138,127139,127140,127141,127142,127143,127144,127145,127146,127147,127149,127150,127137];
const deckMap    = [].concat(clubMap,diamondMap,heartMap,spadeMap);

const nCardsPerSuit   = 13;
const nCardsPerPlayer = 2;
const nCardsPerBoard  = 5;
const nCardsPerHand   = 5;
const nPlayers        = 8;
const nDeck           = deckMap.length; // 52
const nMaxPlayers     = Math.floor((nDeck-nCardsPerBoard)/nCardsPerPlayer); // 52-5=47, no burns, 2 cards each = 46/2 = 23 max players


const deck = sequence(nDeck); // 0-12 clubs, 13-25 diamonds, 26-38 hearts, 39-51 spades
//shuffle(deck);

function renderGame() {
  document.body.innerHTML = '';
  let cardsEl = document.createElement('div'); //getElementById('cards');
  document.body.appendChild(cardsEl);

  for(let i=0;i<nCardsPerBoard;i++) {
    cardsEl.appendChild( getCardEl(deck[i]) );
  }

  for(let i=0;i<Math.min(nPlayers*nCardsPerPlayer, nMaxPlayers);i+=nCardsPerPlayer) {
    let playerEl = document.createElement('div');

    let playerHand = deck.slice(0, nCardsPerBoard);

    for(let j=0;j<nCardsPerPlayer;j++) {
      let cardNo = deck[nCardsPerBoard+(i*nCardsPerPlayer)+j];
      playerHand.push(cardNo);
      playerEl.appendChild(getCardEl(cardNo));
    }

    let playerRank = calculateFullRank(playerHand);
    let playerRankEl = document.createTextNode(playerRank);
    playerEl.appendChild(playerRankEl);

    document.body.appendChild(playerEl);
  }
}

function getCardEl(cardNo) {
  let cardUnicode = deckMap[cardNo];
  let color = cardNo >= DIAMOND2 && cardNo <= HEARTA ? 'c00' : '000';
  let cardEl = document.createElement('span');
  let cardInnerEl = document.createElement('span');
  cardEl.setAttribute('class', 'card');
  cardEl.setAttribute('style', `color:#${color};border-color:${color}`);

  cardInnerEl.innerHTML = `&#${cardUnicode};`; // because most implementations of javascript only support 16-bit javascript, we need to use 32-bit HTML specialchars
  cardEl.appendChild(cardInnerEl);
  return cardEl;
}

function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}

function calculateRank(handArray) { // returnsa 6-digit base-13 number
  // if(handArray.length != (nCardsPerPlayer + nCardsPerBoard)) {
  //   throw new Error( `Calculate Rank Error: Invalid hand size. Expected (${nCardsPerPlayer + nCardsPerBoard}), but was (${handArray.length})` );
  // }
  // I dunno, is using psudo-booleans a good thing?

  return isRoyalFlush(handArray) ? isRoyalFlush(handArray) : 
      isStraightFlush(handArray) ? isStraightFlush(handArray) :
           isFourKind(handArray) ? isFourKind(handArray) :
          isFullHouse(handArray) ? isFullHouse(handArray) :
              isFlush(handArray) ? isFlush(handArray) :
           isStraight(handArray) ? isStraight(handArray) :
          isThreeKind(handArray) ? isThreeKind(handArray) :
            isTwoPair(handArray) ? isTwoPair(handArray) :
               isPair(handArray) ? isPair(handArray) :
           isHighCard(handArray) ? isHighCard(handArray) :
                                   0;
}

function sequence( n ) {
  return Array.from( {length: n}, (x, y) => y );
}

function zeros( n ) {
  return new Array( n + 1 ).join( '0' ).split( '' ).map( parseFloat );
}

Array.prototype.containsAll = function(...els) {
  return els.every(e => this.includes(e));
};

Array.prototype.containsAny = function(...els) {
  return els.some(e => this.includes(e));
};

function isRoyalFlush(handArray) {
  const isRoyalClubs    = handArray.containsAll( CLUBT, CLUBJ, CLUBQ, CLUBK, CLUBA );
  const isRoyalDiamonds = handArray.containsAll( DIAMONDT, DIAMONDJ, DIAMONDQ, DIAMONDK, DIAMONDA );
  const isRoyalHearts   = handArray.containsAll( HEARTT, HEARTJ, HEARTQ, HEARTK, HEARTA );
  const isRoyalSpades   = handArray.containsAll( SPADET, SPADEJ, SPADEQ, SPADEK, SPADEA );
  return ( isRoyalClubs | isRoyalDiamonds | isRoyalHearts | isRoyalSpades ) ; // @todo* RANK.ROYAL_FLUSH.TRI;
}

function isFlush(handArray) {
  let noClubs = 0;
  let noDiamonds = 0;
  let noHearts = 0;
  let noSpades = 0;

  handArray.forEach(card => {
         if(card <= CLUBA ) noClubs++;
    else if(card >= DIAMOND2 && card <= DIAMONDA ) noDiamonds++
    else if(card >= HEART2 && card <= HEARTA ) noHearts++
    else if(card >= SPADE2 && card <= SPADEA ) noSpades++
  });

  const isClubFlush = noClubs >= nCardsPerHand;
  const isDiamondFlush = noDiamonds >= nCardsPerHand;
  const isHeartFlush = noHearts >= nCardsPerHand;
  const isSpadeFlush = noSpades >= nCardsPerHand;

  return isClubFlush | isDiamondFlush | isHeartFlush | isSpadeFlush;
}

function sortedSuitAgnosticSet(handArray) {
  return Array.from( new Set(handArray.map( x => x % nCardsPerSuit ).sort((a, b) => a - b)) );
}

function cardTypeCount( handArray ) { // returns counter array ace to king
  let count = zeros( nCardsPerSuit );
  handArray.forEach( x => { count[ x % nCardsPerSuit ]++ } );
  return count;
}

function isStraight(handArray) {
  let runString = '';
  let suitAgnosticArray = sortedSuitAgnosticSet( handArray );
  // ALL BROKEN
  //let highestRank = 
  // if(suitAgnosticArray.reverse(0) === 0 ) {
  //   suitAgnosticArray.unshift(nCardsPerSuit); //aces count at both ends in a straight
  // }

  let last = suitAgnosticArray[suitAgnosticArray.length-1];
  let runLength = nCardsPerHand - 1;
  let run = 0;

  for(let i=suitAgnosticArray.length-2;i>=0;i--) {
    if(suitAgnosticArray[i]+1 === last) {
      run++;
    } else {
      run = 0;
    }
    if( run === runLength ) {
      return 1 + ( ( suitAgnosticArray[i] + runLength ) % nCardsPerSuit );
    }
    last = suitAgnosticArray[i];
  }
  return 0;
}

function isStraightFlush(handArray) {
  let clubSubset = [];
  let diamondSubset = [];
  let heartSubset = [];
  let spadeSubset = [];

  handArray.forEach( card => {
         if(                    card <= CLUBA    ) clubSubset.push(card);
    else if(card >= DIAMOND2 && card <= DIAMONDA ) diamondSubset.push(card);
    else if(card >= HEART2   && card <= HEARTA   ) heartSubset.push(card);
    else if(card >= SPADE2   && card <= SPADEA   ) spadeSubset.push(card);
  });

  return isStraight(clubSubset) | isStraight(diamondSubset) | isStraight(heartSubset) | isStraight(spadeSubset);
}

function isFourKind(handArray) {
  let typeCount = cardTypeCount(handArray);
  return typeCount.indexOf(4) + 1;
}

function isThreeKind(handArray) {
  let typeCount = cardTypeCount(handArray);
  return typeCount.indexOf(3) + 1;
}

function isFullHouse(handArray) {
  let reverseSortedTypeCount = cardTypeCount(handArray).sort((a, b) => b - a);
  return reverseSortedTypeCount[0] === 3 && reverseSortedTypeCount[1] >= 2;
}

function isTwoPair(handArray) {
  let reverseSortedTypeCount = cardTypeCount(handArray).sort((a, b) => b - a);
  return reverseSortedTypeCount[0] === 2 && reverseSortedTypeCount[1] === 2;
}
function isPair(handArray) {
  let reverseSortedTypeCount = cardTypeCount(handArray).sort((a, b) => b - a);
  return reverseSortedTypeCount[0] === 2;
}

function isHighCard(handArray) {
  return true;
}

function toCardString(oneIndexedCard) { // keep it at one so false (0) results in unknown kicker
  return oneIndexedCard ===  1 ? 'deuce' :
         oneIndexedCard ===  2 ? 'three' :
         oneIndexedCard ===  3 ? 'four'  :
         oneIndexedCard ===  4 ? 'five'  :
         oneIndexedCard ===  5 ? 'six'   :
         oneIndexedCard ===  6 ? 'seven' :
         oneIndexedCard ===  7 ? 'eight' :
         oneIndexedCard ===  8 ? 'nine'  :
         oneIndexedCard ===  9 ? 'ten'   :
         oneIndexedCard === 10 ? 'jack'  :
         oneIndexedCard === 11 ? 'queen' :
         oneIndexedCard === 12 ? 'king'  :
         oneIndexedCard === 13 ? 'ace'   :
                                 false;
}

function testRank(rankType) {
  console.log('Testing for: '+rankType);
  for(let i=0;i<1000000;i++) {
    shuffle(deck);
    let handArray = deck.slice(0,7);
    if(calculateRank(handArray) === rankType ) {
      console.log(`${rankType} achived for p1 on the ${i}th iteration!`);
      console.log(deck.slice(0,7));
      renderGame();
      break;
    }
  }
}

function calculateWinners(...hands) {

  // calculate rank
  // if > 1people with same rank, calculate high (or split if equivilent hand/no high)
  // if > 1 people with same high, caluclate kicker(s) (or split if equivilent hand/no kickers)

}

shuffle(deck);
renderGame();

// testRank(RANK.ROYAL_FLUSH);
// testRank(RANK.STRAIGHT_FLUSH);
// testRank(RANK.FOUR_KIND);
// testRank(RANK.FULL_HOUSE);
// testRank(RANK.FLUSH);
// testRank(RANK.STRAIGHT);
// testRank(RANK.THREE_KIND);
// testRank(RANK.TWO_PAIR);
// testRank(RANK.PAIR);
// testRank(RANK.HIGH_CARD);


// format:
// [highcard, kicker, kicker, kicker]


</script>
</html>
